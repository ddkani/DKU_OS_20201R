디스크, 트랙, 섹터로 이루어짐

논리 파일 오프셋 - 물리적 블록 번호와 논리적 물리 번호로 이루어짐.
물리 블록이 논리 블록을 포함함

스토리지의 데이터 위치를 파일의 논리 위치와 맵핑함.


#1. i-노드 정보를 저장해야 함.
i-노드 블럭에서 모든 i노드는 어레이로 저장됨.

특수 블록인 수퍼 블록을 정의함. 
전체 시스템 파일 정보 - i 노드 크기, 수 / 남은 i노드 블록, i노드의 실제 사용, 첫번째 블록 번호, 볼륨 이름등


스토리지 파티션 : 수퍼 블록, i-노드 테이블, 데이터 블록 / i 노드 테이블은 메모리에 로드되어야 함.
수퍼 블록 - 루트 파일 정보, '/' 파일의 i 노드 정보

디렉터리는 특수한 파일의 형태이며, 사람이 읽을 수 있는 파일을 이름을 색인 번호로 매핑. (구조적 계층 작성 가능)


/* 구현이 필요한 함수

FILE *fopen(const char *filename, const char *mode) 
파일을 열고, file descriptor를 반환합니다.

size_t fread(void* ptr, size_t size, size_t count, FILE *stream);

size * count 만큼의 데이터를 FILE 디스크립터에서 읽어 버퍼에 저장합니다.
읽어들인 데이터의 크기를 반환합니다.

- size: 읽어들일 원소의 바이트 크기
- count : 읽어들일 원소의 갯수

int fclose(FILE *stream)
파일을 닫고, 성공 시 0, 실패 시 -1(EOF) 를 반환합니다.
*/



// TODO: 실제로 각 응용프로그램들은 같은 파일에 공유 접근할경우,
// 파일디스크립터테이블에 있는 파일디스크립터들을 따로따로 참조하고
// 이 파일오브젝트들은 하나의 아이노드에 접근하게된다.

// 응용프로그램은 실제 커널의 아이노드테이블, 파일디스크립터를 가져오게된다.
// 파일디스크립터 -> 하나의 아이노드

// 0x2000 (8192) 바이트는 슈퍼블록과 아이노드로 사용함.
// 0x50 (80) ?
// 이후 총 4개 블럭 (4k)에 이름이 32바이트 단위로 들어 있음.
// 파일 100개 총 103 블럭 사용.